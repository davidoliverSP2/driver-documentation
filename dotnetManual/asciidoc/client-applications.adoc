[[dotnet-driver-client-applications]]
= Client applications

[abstract]
--
This section describes how to manage database connections within an application.
--


[[dotnet-driver-driver-object]]
== The Driver Object

include::{common-content}/client-applications.adoc[tag=object]

To construct a driver instance, a <<dotnet-driver-connection-uris, connection URI>> and <<dotnet-driver-authentication, authentication information>> must be supplied.

Additional configuration details can be supplied if required.
The configuration details are immutable for the lifetime of the Driver Object.
Therefore, if multiple configurations are required (such as when working with multiple database users) then multiple Driver Objects must be used.



.The driver lifecycle
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=driver-lifecycle]
----

// .Import driver lifecycle
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=driver-lifecycle-import]
// ----


[[dotnet-driver-connection-uris]]
== Connection URIs

include::{common-content}/client-applications.adoc[tag=uris]


[NOTE]
====
https://neo4j.com/aura/[*Neo4j Aura*] is a *_secure hosted service_* backed by full certificates signed by a root certificate authority.

To connect to *Neo4j Aura*, driver users must *_enable encryption_* and the complete set of certificate checks (the latter of which are enabled by default).

For more information, see <<dotnet-driver-configuration-examples>> below.
====

include::{common-content}/client-applications.adoc[tag=default-security-changes]


[[dotnet-initial-address-resolution]]
=== Initial address resolution

include::{common-content}/client-applications.adoc[tag=initial-address-resolution]


[[dotnet-dns-resolution]]
==== DNS resolution

include::{common-content}/client-applications.adoc[tag=dns-resolution]


[[dotnet-custom-middleware]]
==== Custom middleware

include::{common-content}/client-applications.adoc[tag=custom-middleware]


[[dotnet-driver-resolver-function]]
==== Resolver function

include::{common-content}/client-applications.adoc[tag=resolver-function]

.Custom Address Resolver
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-custom-resolver]
----


[[dotnet-driver-routing-table]]
=== Routing table

include::{common-content}/client-applications.adoc[tag=routing-table]


[[dotnet-driver-routing-context]]
=== Routing context

include::{common-content}/client-applications.adoc[tag=routing-context]


[[dotnet-driver-configuration-examples]]
=== Examples

include::{common-content}/client-applications.adoc[tag=examples-pt1]

In a clustered environment, the URI address will resolve to one of more of the core members; for standalone installations, this will simply point to that server address.
The `ROUTING_CONTEXT` option allows for customization of the routing table and is discussed in more detail in <<dotnet-driver-routing-context>>.

include::{common-content}/client-applications.adoc[tag=examples-pt2]

.Connecting to a service
The table below illustrates examples of how to connect to a service with routing:

[options="header", cols="a,a,a,a"]
|===
|Product
|Security
|Code snippet
|Comments

|Neo4j Aura
|Secured with full certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted));
----
| This is the default (and only option) for Neo4j Aura

|Neo4j 4.x
|Unsecured
|
[source, csharp]
----
GraphDatabase.Driver("neo4j://graph.example.com:7687", auth);
----
|This is the default for Neo4j 4.x series

|Neo4j 4.x
|Secured with full certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted));
----
|

|Neo4j 4.x
|Secured with self-signed certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+ssc://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted)
                 .WithTrustManager(TrustManager.CreateInsecure()));
----
|

|Neo4j 3.x
|Secured with full certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted));
----
|

|Neo4j 3.x
|Secured with self-signed certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+ssc://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted)
                 .WithTrustManager(TrustManager.CreateInsecure()));
----
|This is the default for Neo4j 3.x series

|Neo4j 3.x
|Unsecured
|
[source, csharp]
----
GraphDatabase.Driver("neo4j://graph.example.com:7687", auth);
----
|

|===

[NOTE]
To connect to a service without routing, you can replace `neo4j` with `bolt`.


[[dotnet-driver-authentication]]
== Authentication

include::{common-content}/client-applications.adoc[tag=authentication]


[[dotnet-driver-authentication-basic]]
=== Basic authentication

include::{common-content}/client-applications.adoc[tag=authentication-basic]

.Basic authentication
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=basic-auth]
----

// .Import basic authentication
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=basic-auth-import]
// ----

include::{common-content}/client-applications.adoc[tag=authentication-basic-note]


[[dotnet-driver-authentication-kerberos]]
=== Kerberos authentication

include::{common-content}/client-applications.adoc[tag=authentication-kerberos]

.Kerberos authentication
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=kerberos-auth]
----

// .Import Kerberos authentication
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=kerberos-auth-import]
// ----

include::{common-content}/client-applications.adoc[tag=authentication-kerberos-note]


[[dotnet-driver-authentication-custom]]
=== Custom authentication

For advanced deployments, where a custom security provider has been built, the custom authentication helper can be used.

.Custom authentication
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=custom-auth]
----

// .Import custom authentication
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=custom-auth-import]
// ----


[[dotnet-driver-configuration]]
== Configuration

`ConnectionAcquisitionTimeout`::

The maximum amount of time a session will wait when requesting a connection from the connection pool.
For connection pools where all connections are currently being used and the `MaxConnectionPoolSize` limit has been reached, a session will wait this duration for a connection to be made available.
Since the process of acquiring a connection may involve creating a new connection, *_ensure that the value of this configuration is higher than the configured_* `ConnectionTimeout`.
+
Setting a low value will allow for transactions to *_fail fast_* when all connections in the pool have been acquired by other transactions.
Setting a higher value will result in these transactions being queued, increasing the chances of eventually acquiring a connection at the cost of longer time to receive feedback on failure.
Finding an optimal value may require an element of experimentation, taking into consideration the expected levels of parallelism within your application as well as the `MaxConnectionPoolSize`.
+
*Default:* 60 seconds

.Configure connection pool
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-connection-pool]
----
// .Import connection pool configuration
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-connection-pool-import]
// ----

`ConnectionTimeout`::

The maximum amount of time to wait for a TCP connection to be established.
Connections are only created when a session requires one unless there is an available connection in the connection pool.
The driver maintains a pool of open connections which can be loaned to a session when one is available.
If a connection is not available, then an attempt to create a new connection (provided the `MaxConnectionPoolSize` limit has not been reached) is made with this configuration option, providing the maximum amount of time to wait for the connection to be established.
+
In environments with high latency and high occurrences of connection timeouts it is recommended to configure a higher value.
For lower latency environments and quicker feedback on potential network issues configure with a lower value.
+
*Default:* 30 seconds


.Configure connection timeout
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-connection-timeout]
----

// .Import connection timeout configuration
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-connection-timeout-import]
// ----

`CustomResolver`::

Specify a custom server address resolver used by the routing driver to resolve the initial address used to create the driver. See <<dotnet-driver-resolver-function>> for more details.

`Encryption`::

Specify whether to use an encrypted connection between the driver and server.
+
*Default:* None

.Unencrypted configuration
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-unencrypted]
----
// .Import unencrypted configuration
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-unencrypted-import]
// ----

`MaxConnectionLifetime`::

The maximum duration the driver will keep a connection for before being removed from the pool.
Note that while the driver will respect this value, it is possible that the network environment will close connections inside this lifetime.
This is beyond the control of the driver.
The check on the connection’s lifetime happens when a session requires a connection.
If the available connection’s lifetime is over this limit it is closed and a new connection is created, added to the pool and returned to the requesting session.
Changing this configuration value would be useful in environments where users don’t have full control over the network environment and wish to proactively ensure all connections are ready.
+
Setting this option to a low value will cause a high connection churn rate, and can result in a performance drop.
It is recommended to pick a value smaller than the maximum lifetime exposed by the surrounding system infrastructure (such as operating system, router, load balancer, proxy and firewall).
Negative values result in lifetime not being checked.
+
*Default:* 1 hour (3600 seconds)

`MaxConnectionPoolSize`::

The maximum total number of connections allowed, per host (i.e. cluster nodes), to be managed by the connection pool.
In other words, for a direct driver using the `bolt://` scheme, this sets the maximum number of connections towards a single database server.
For a driver connected to a cluster using the `neo4j://` scheme, this sets the maximum amount of connections per cluster member.
If a session or transaction tries to acquire a connection at a time when the pool size is at its full capacity, it must wait until a free connection is available in the pool or the request to acquire a new connection times out.
The connection acquiring timeout is configured via `ConnectionAcquisitionTimeout`.
+
This configuration option allows you to manage the memory and I/O resources being used by the driver and tuning this option is dependent on these factors, in addition to number of cluster members.
+
*Default:* 100 connections (except .NET Driver with 500 connections)

`MaxTransactionRetryTime`::

The maximum amount of time that a managed transaction will retry for before failing. Queries that are executed within a managed transaction gain the benefit of being retried when a transient error occurs.
When this happens the transaction is retired multiple times up to the `MaxTransactionRetryTime`.
+
Configure this option higher in high latency environments or if you are executing many large transactions which could limit the number of times that they are retired and therefore their chance to succeed.
Configure lower in low latency environments and where your workload mainly consists of many smaller transactions.
Failing transactions faster may highlight the reasons behind the transient errors making it easier to fix underlying issues.
+
*Default:* 30 seconds

.Configure maximum retry time
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-max-retry-time]
----
// .Import maximum retry time configuration
// [.include-with-dotnet]
// ======
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-max-retry-time-import]
// ----

`TrustStrategy`::

Specify how to determine the authenticity of encryption certificates provided by the Neo4j instance that you are connecting to.
There are three choices as to which strategy to use:

* `TRUST_SYSTEM_CA_SIGNED_CERTIFICATES` - Accept any certificate that can be verified against a custom CA.

* `TRUST_CUSTOM_CA_SIGNED_CERTIFICATES` - Accept any certificate that can be verified against the system store.

* `TRUST_ALL_CERTIFICATES` - Accept any certificate provided by the server, regardless of CA chain. *We do not recommend using this setting for production environments.*

+
*Default:* `TRUST_SYSTEM_CA_SIGNED_CERTIFICATES` (Note - only when encryption is enabled)

.Configure trusted certificates

`KeepAlive`::

Specify whether TCP keep-alive should be enabled. To ensure that the connection between the driver and server is still operational, the TCP layer can periodically send messages to check the connection.
+
*Default:* True


[[dotnet-driver-logging]]
== Logging

All official *Neo4j Drivers* log information to standard logging channels.
This can typically be accessed in an ecosystem-specific way.

The code snippet below demonstrates how to redirect log messages to standard output:

[source, csharp]
----
#Please note that you will have to provide your own console logger implementing the ILogger interface.
IDriver driver = GraphDatabase.Driver(..., o => o.WithLogger(logger));
----
